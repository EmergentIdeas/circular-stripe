{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "client-js/circular-stripe.js",
    "client-js/pages.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()",
    "\n\nclass CircularStripe {\n\t/**\n\t * Expects an element like .circular-stripe-holder with markup roughly like:\n\t * \n\t * \t<div class=\"circular-stripe-holder\">\n\t *\t\t<div class=\"circular-stripe\">\n\t *\t\t\t<div class=\"mover\">\n\t *\t\t\t\t<div>content</div><div>content</div><div>content</div>\n\t *\t\t\t</div>\n\t * \t\t</div>\n\t * \t\t<button class=\"previous\">previous</button>\n\t * \t\t<button class=\"next\">next</button>\n\t * \t\t<div class=\"dots\"></div>\n\t * \t</div>\n\t * \n\t * @param {Element} stripeElementHolder The holder of the working elements for the circular stripe\n\t * @param {Object} [options]\n\t * @param {int} [options.animationDuration=300] The length of time taken for the slide animation in milliseconds\n\t * @param {int} [options.stepSize=5] length of time taken between frames in the slide animation in milliseconds\n\t * @param {int} [options.sidePadding=1000] The number of pixels used to provide offscreen work area\n\t * @param {string} [options.positionAttributeName=data-original-position] The name of the attribute used to track the item's original position\n\t * @param {string} [options.currentClassName=current] The class added to the current item and current dot\n\t */\n\tconstructor(stripeElementHolder, options) {\n\n\t\t// Setup working properties\n\t\tObject.assign(this, {\n\t\t\tanimationDuration: 300\n\t\t\t, stepSize: 5\n\t\t\t, sidePadding: 1000\n\t\t\t, positionAttributeName: 'data-original-position'\n\t\t\t, currentClassName: 'current'\n\t\t}, options)\n\n\t\t// find possible parts\n\t\tthis.stripeElementHolder = stripeElementHolder\n\t\tthis.stripeElement = stripeElementHolder.querySelector('.circular-stripe')\n\t\tthis.mover = this.stripeElement.querySelector('.mover')\n\t\tthis.nextButton = this.stripeElementHolder.querySelector('.next')\n\t\tthis.previousButton = this.stripeElementHolder.querySelector('.previous')\n\t\tthis.dots = this.stripeElementHolder.querySelector('.dots')\n\n\t\tthis.mover.style.paddingLeft = this.sidePadding + 'px'\n\t\tthis.mover.style.paddingRight = this.sidePadding + 'px'\n\n\t\t// mark the items with their original positions\n\t\tfor (let i = 0; i < this.mover.children.length; i++) {\n\t\t\tthis.mover.children[i].setAttribute(this.positionAttributeName, i)\n\t\t}\n\n\t\tthis._addDots()\n\t\tthis._addEventListeners()\n\t}\n\n\t_addDots() {\n\t\tif (this.dots) {\n\t\t\tlet count = this.mover.children.length\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tthis.dots.innerHTML += `<button class=\"dot\" ${this.positionAttributeName}=\"${i}\">&nbsp;</button>`\n\t\t\t}\n\n\t\t\tthis.dots.querySelectorAll('.dot').forEach(dot => {\n\t\t\t\tdot.addEventListener('click', evt => {\n\t\t\t\t\tlet ind = evt.currentTarget.getAttribute(this.positionAttributeName)\n\t\t\t\t\t// console.log(`dot clicked: ${ind}`)\n\n\t\t\t\t\tlet e = new Event('dotClicked')\n\t\t\t\t\te.ind = ind\n\t\t\t\t\te.dotElement = evt.currentTarget\n\t\t\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\t\t\tlet child = this.mover.children[i]\n\t\t\t\t\t\tif (child.getAttribute(this.positionAttributeName) == ind) {\n\t\t\t\t\t\t\te.itemElement = child\n\t\t\t\t\t\t\te.itemCurrentPosition = i\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.stripeElementHolder.dispatchEvent(e)\n\t\t\t\t})\n\t\t\t})\n\t\t}\n\t}\n\n\t/**\n\t * Configures event listeners for the possible components in the stripe\n\t */\n\t_addEventListeners() {\n\t\tthis.stripeElement.addEventListener('scroll', evt => {\n\t\t\tif (!this.animating) {\n\t\t\t\twindow.requestAnimationFrame(() => {\n\t\t\t\t\tthis.rebalance()\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\n\t\tif (this.nextButton) {\n\t\t\tthis.nextButton.addEventListener('click', evt => {\n\t\t\t\tthis.centerItemToRight()\n\t\t\t})\n\t\t}\n\t\tif (this.previousButton) {\n\t\t\tthis.previousButton.addEventListener('click', evt => {\n\t\t\t\tthis.centerItemToLeft()\n\t\t\t})\n\t\t}\n\t\t\n\t\tthis.mover.addEventListener('click', evt => {\n\t\t\tif(!evt.target.classList.contains('mover')) {\n\t\t\t\tlet item = evt.target.closest('.mover > *')\n\t\t\t\tlet e = new Event('itemClicked')\n\t\t\t\te.ind = item.getAttribute(this.positionAttributeName)\n\t\t\t\te.itemElement = item\n\t\t\t\tthis.stripeElementHolder.dispatchEvent(e)\n\t\t\t}\n\t\t})\n\n\t\tthis.addEventListener('center', (evt) => {\n\t\t\tthis._onCenterItem(evt.nextItemOriginalIndex, evt.nextItemIndex)\n\t\t})\n\n\t\tthis.addEventListener('dotClicked', (evt) => {\n\t\t\tlet { ind: dotIndex, dotElement, itemElement, itemCurrentPosition } = evt\n\t\t\tthis._onDotClicked(dotIndex, itemCurrentPosition, dotElement, itemElement)\n\t\t})\n\n\t\twindow.addEventListener('resize', (evt) => {\n\t\t\tthis.rebalance()\n\t\t})\n\n\t}\n\n\t/**\n\t * Listen for events from this component.\n\t * The available events are: \n\t * center: an item is being explicitly centered\n\t * dotClicked: the user has clicked one of the tracking dots\n\t * itemClicked: the user has clicked one of the items\n\t * @param {string} event The event name\n\t * @param {function(evt:Event)} func A function which is passed an Event object\n\t */\n\taddEventListener(event, func) {\n\t\tthis.stripeElementHolder.addEventListener(event, func)\n\t}\n\n\t_onCenterItem(nextItemOriginalIndex, nextItemIndex) {\n\n\t}\n\n\t_onDotClicked(dotIndex, itemCurrentPosition, dotElement, itemElement) {\n\t\tthis.center(itemCurrentPosition, true)\n\t\tthis.rebalance()\n\t}\n\n\t_remark() {\n\t\tlet centered = this.getCenterItem()\n\t\tif (centered) {\n\t\t\tthis._updateCurrentStyling(centered.item.getAttribute(this.positionAttributeName), centered.ind)\n\t\t}\n\n\t}\n\n\t_updateCurrentStyling(dotIndex, itemIndex) {\n\t\tif(this.dots) {\n\t\t\t[...this.dots.children].forEach(dot => dot.classList.remove(this.currentClassName))\n\t\t\tthis.dots.children[dotIndex].classList.add(this.currentClassName);\n\t\t}\n\n\t\t[...this.mover.children].forEach(item => item.classList.remove(this.currentClassName))\n\t\tthis.mover.children[itemIndex].classList.add(this.currentClassName)\n\t}\n\n\n\t/**\n\t * Animates the change of a property over a duration. Normally you might use\n\t * css transition to do this, but there are some properties that doesn't work\n\t * for (scroll positions).  \n\t * \n\t * This method used a linear animation.\n\t * \n\t * @param {Object} propertyHolder \n\t * @param {string} propertyName \n\t * @param {int} start \n\t * @param {int} end \n\t * @param {int} duration Time in milliseconds \n\t */\n\tanimateProperty(propertyHolder, propertyName, start, end, duration) {\n\t\tthis.animating = true\n\t\tlet count = parseInt(duration / this.stepSize)\n\t\tlet increment = (end - start) / count\n\t\tlet accumulator = propertyHolder[propertyName]\n\t\tlet intervalTracker = setInterval(() => {\n\t\t\tcount--\n\t\t\taccumulator += increment\n\t\t\tpropertyHolder[propertyName] = accumulator\n\n\n\t\t\tif (count == 0) {\n\t\t\t\tclearInterval(intervalTracker)\n\t\t\t\tpropertyHolder[propertyName] = end\n\t\t\t\tthis.animating = false\n\t\t\t\tthis.rebalance()\n\t\t\t}\n\n\t\t}, this.stepSize)\n\t}\n\n\n\t/**\n\t * \n\t * @returns {int} The pixel with of all the items in the .mover\n\t */\n\t_getItemsTotalWidth() {\n\t\tlet totalItemWidths = 0\n\t\tlet mover = this.mover\n\t\tfor (let el of mover.children) {\n\t\t\ttotalItemWidths += el.offsetWidth\n\t\t}\n\t\treturn totalItemWidths\n\t}\n\n\t/**\n\t * Resizes the .mover element so that it comfortably holds all of the items.\n\t * This is something you'd think should work out naturally with various css\n\t * styling, but it didn't. It would be a nice future improvment to style the\n\t * .mover so that this method is no longer needed.\n\t */\n\t_resizeMover() {\n\t\tlet totalItemWidths = this._getItemsTotalWidth()\n\t\tthis.mover.style.width = ((this.sidePadding * 2) + totalItemWidths) + 'px'\n\t}\n\n\t/**\n\t * Centers the item to the right of the currently centered item.\n\t * This movement is performed with an animation.\n\t */\n\tcenterItemToRight() {\n\t\tlet centered = this.getCenterItem()\n\t\tif (centered) {\n\t\t\tthis.center(centered.ind + 1, true)\n\t\t}\n\t\telse {\n\t\t\tthis.center(null, true)\n\t\t}\n\t\tthis.rebalance()\n\t}\n\n\t/**\n\t * Centers the item to the left of the currently centered item.\n\t * This movement is performed with an animation\n\t */\n\tcenterItemToLeft() {\n\t\tlet centered = this.getCenterItem()\n\t\tif (centered) {\n\t\t\tlet next = centered.ind - 1\n\t\t\tif (next < 0) {\n\t\t\t\tnext = 0\n\t\t\t}\n\t\t\tthis.center(next, true)\n\t\t}\n\t\telse {\n\t\t\tthis.center(null, true)\n\t\t}\n\t\tthis.rebalance()\n\t}\n\n\t/**\n\t * Centers the elements in the frame, optionally on a specific element\n\t * \n\t * Calling this method with a specific item causes a 'center' event to be dispatched.\n\t * \n\t * @param {null,int} [item] - an optional element that specifies what should be centered\n\t * @param {boolean} [animate] If true, the centering will be done as a slide animation. If false\n\t * or undefined no animation will take place.\n\t */\n\tcenter(item, animate) {\n\t\tthis._resizeMover()\n\t\tlet se = this.stripeElement;\n\t\tlet stripeWidth = se.offsetWidth\n\t\tlet mover = this.mover\n\n\t\tif (!item) {\n\t\t\tlet itemWidth = this._getItemsTotalWidth()\n\t\t\tlet additionalOffset = (itemWidth - stripeWidth) / 2\n\t\t\tif (animate) {\n\t\t\t\tthis.animateProperty(se, 'scrollLeft', se.scrollLeft, this.sidePadding + additionalOffset, this.animationDuration)\n\t\t\t}\n\t\t\telse {\n\t\t\t\tse.scrollLeft = this.sidePadding + (additionalOffset)\n\t\t\t}\n\t\t}\n\t\tif (Number.isInteger(item)) {\n\t\t\tlet child = mover.children[item]\n\t\t\tif (!child) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tlet childWidth = child.offsetWidth\n\t\t\tlet childLeft = child.offsetLeft\n\t\t\tlet childCenter = childLeft + (childWidth / 2)\n\n\t\t\tif (animate) {\n\t\t\t\tthis.animateProperty(se, 'scrollLeft', se.scrollLeft, childCenter - (stripeWidth / 2), this.animationDuration)\n\t\t\t}\n\t\t\telse {\n\t\t\t\tse.scrollLeft = childCenter - (stripeWidth / 2)\n\t\t\t}\n\n\t\t\tlet evt = new Event('center')\n\t\t\tevt.nextItemOriginalIndex = parseInt(child.getAttribute(this.positionAttributeName))\n\t\t\tevt.nextItemIndex = item\n\t\t\tthis.stripeElementHolder.dispatchEvent(evt)\n\t\t}\n\t}\n\t\n\t_getCenterPosition() {\n\t\tlet se = this.stripeElement;\n\t\tlet stripeWidth = se.offsetWidth\n\t\treturn se.scrollLeft + (stripeWidth / 2)\n\t}\n\n\t/**\n\t * Returns the item currently under the center line of the .circular-stripe element.\n\t * @returns {{ind: int, item: Element}} Returns the index and element item which is currently \n\t * centered. If no item is centered, returns null.\n\t */\n\tgetCenterItem() {\n\t\tthis._resizeMover()\n\t\tlet se = this.stripeElement;\n\t\tlet stripeWidth = se.offsetWidth\n\n\t\tlet centerPosition = this._getCenterPosition()\n\n\t\tlet count = 0\n\t\tfor (let el of this.mover.children) {\n\t\t\tlet childOffset = el.offsetLeft\n\t\t\tlet childWidth = el.offsetWidth\n\t\t\tif (childOffset <= centerPosition && (childOffset + childWidth) >= centerPosition) {\n\t\t\t\treturn {\n\t\t\t\t\tind: count,\n\t\t\t\t\titem: el\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount++\n\t\t}\n\t}\n\n\t/**\n\t * Calculates a numeric measure of balance by incrementing \n\t * for every item to the right of the center item and\n\t * decrementing for every item to the left.\n\t * \n\t * A balance of 1 would indicate there are one more items\n\t * to the right than to the left of the centered item.\n\t * \n\t * A balance of -2 would indicate two more to the left than\n\t * to the right\n\t * @returns {int} The balance\n\t */\n\t_getBalance() {\n\t\tthis._resizeMover()\n\n\t\tlet centerPosition = this._getCenterPosition()\n\t\tlet balance = 0\n\n\t\tfor (let el of this.mover.children) {\n\t\t\tlet childOffset = el.offsetLeft\n\t\t\tlet childWidth = el.offsetWidth\n\n\t\t\tif ((childOffset + childWidth) < centerPosition) {\n\t\t\t\tbalance--\n\t\t\t}\n\t\t\tif (childOffset > centerPosition) {\n\t\t\t\tbalance++\n\t\t\t}\n\t\t}\n\t\treturn balance\n\t}\n\n\t/**\n\t * Rebalances the stripe so roughly as many items are to the \n\t * right of the center item as are to the left of the center\n\t * item\n\t */\n\trebalance() {\n\t\tlet trigger = 2\n\t\tlet balance = this._getBalance()\n\t\tif (balance <= -1 * trigger) {\n\t\t\tlet shift = 1 + Math.abs(balance) - trigger\n\t\t\twhile (shift--) {\n\t\t\t\tthis._moveFromLeftToRight()\n\t\t\t}\n\t\t}\n\t\telse if (balance >= trigger) {\n\t\t\tlet shift = 1 + Math.abs(balance) - trigger\n\t\t\twhile (shift--) {\n\t\t\t\tthis._moveFromRightToLeft()\n\t\t\t}\n\t\t}\n\t\tthis._remark()\n\t}\n\n\t/**\n\t * Moves one item from the right side of the stripe to the left\n\t */\n\t_moveFromRightToLeft() {\n\t\tthis._resizeMover()\n\t\tlet se = this.stripeElement\n\t\tlet mover = this.mover\n\t\tlet nodeWidth = mover.lastElementChild.offsetWidth\n\n\t\tmover.insertBefore(mover.lastElementChild, mover.firstElementChild)\n\t\tse.scrollLeft += nodeWidth\n\t}\n\n\t/**\n\t * Moves one item from the left side of the stripe to the right side\n\t */\n\t_moveFromLeftToRight() {\n\t\tthis._resizeMover()\n\t\tlet se = this.stripeElement\n\t\tlet mover = this.mover\n\t\tlet nodeWidth = mover.firstElementChild.offsetWidth\n\n\t\tmover.lastElementChild.after(mover.firstElementChild)\n\t\tse.scrollLeft -= nodeWidth\n\t}\n\n\n}\n\nif (module) {\n\tmodule.exports = CircularStripe\n}",
    "\nconst CircularStripe = require('./circular-stripe')\nwindow.addEventListener(\"load\", function () {\n\tlet cs\n\tlet stripes = document.getElementsByClassName('circular-stripe-holder')\n\tif (stripes.length > 0) {\n\t\twindow.cs = cs = new CircularStripe(stripes[0])\n\t\tsetTimeout(function () {\n\t\t\tcs.center()\n\t\t})\n\t\tcs.addEventListener('center', (evt) => {\n\t\t\tlet { nextItemOriginalIndex: org, nextItemIndex: now } = evt\n\t\t\tconsole.log(`Now positioning: ${org} (${now})`)\n\t\t})\n\t\tcs.addEventListener('dotClicked', (evt) => {\n\t\t\tlet { ind, dotElement, itemElement, itemCurrentPosition } = evt\n\t\t\tconsole.log(`dot clicked: ${ind} - ${itemElement.getAttribute('data-original-position')} - ${itemCurrentPosition}`)\n\t\t})\n\t\tcs.addEventListener('itemClicked', (evt) => {\n\t\t\tlet { ind, itemElement} = evt\n\t\t\tconsole.log(`item clicked: ${ind} - ${itemElement.innerText}`)\n\t\t})\n\t}\n})\n\n\n\n"
  ]
}